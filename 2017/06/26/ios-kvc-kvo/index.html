<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS KVC 原理与总结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#KVC 原理与总结
KVC 就是key value coding就是用不明确方法对属性进行 存取操作
总体规则 先找相关方法，再找相关变量；具体规则如下：   1.先找相关方法，如果相关方法找不到   2.那么去判断accessInstanceVariablesDirectly (该方法默认返回YES) 是否返回YES   3.如果返回YES，继续再去找相关变量   4.如果没有找到,就会执行K">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS KVC 原理与总结">
<meta property="og:url" content="http://yoursite.com/2017/06/26/ios-kvc-kvo/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="#KVC 原理与总结
KVC 就是key value coding就是用不明确方法对属性进行 存取操作
总体规则 先找相关方法，再找相关变量；具体规则如下：   1.先找相关方法，如果相关方法找不到   2.那么去判断accessInstanceVariablesDirectly (该方法默认返回YES) 是否返回YES   3.如果返回YES，继续再去找相关变量   4.如果没有找到,就会执行K">
<meta property="og:updated_time" content="2017-07-02T04:07:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="iOS KVC 原理与总结">
<meta name="twitter:description" content="#KVC 原理与总结
KVC 就是key value coding就是用不明确方法对属性进行 存取操作
总体规则 先找相关方法，再找相关变量；具体规则如下：   1.先找相关方法，如果相关方法找不到   2.那么去判断accessInstanceVariablesDirectly (该方法默认返回YES) 是否返回YES   3.如果返回YES，继续再去找相关变量   4.如果没有找到,就会执行K">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ios-kvc-kvo" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/26/ios-kvc-kvo/" class="article-date">
  <time datetime="2017-06-26T13:20:50.000Z" itemprop="datePublished">2017-06-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      iOS KVC 原理与总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#KVC 原理与总结</p>
<p>KVC 就是key value coding<br>就是用不明确方法对属性进行 存取操作</p>
<p>总体规则 先找相关方法，再找相关变量；具体规则如下：<br>   1.先找相关方法，如果相关方法找不到<br>   2.那么去判断accessInstanceVariablesDirectly (该方法默认返回YES) 是否返回YES<br>   3.如果返回YES，继续再去找相关变量<br>   4.如果没有找到,就会执行KVC的valueForUndefinedKey,程序崩溃<br>   5.如果返回NO，就会直接执行valueForUndefinedKey</p>
<p>相关方法 getKey,key;setKey,setIsKey  容器方法 数组的 countOfKey objectInKeyAtIndex (NSSet)<br>相关变量 _key(默认生成的),_isKey,key,isKey</p>
<p>valueForKey 饭回是 id类型, 拥有自动装箱的功能,比如属性是int 类型,valueForKey得到的就是NSNumber类型；其他的类型，NSRange、CGRect等会被转变为NSValue。<br>setValue:ForKey 也会开箱操作</p>
<p>使用kvc,为了增强程序的健壮性,可以重写setValueForUndefinedKey,防止程序崩溃<br>可以通过kvc访问私有属性,如果不想让外界访问私有属性可以重写那么去判断accessInstanceVariablesDirectly,返回NO就可以了</p>
<p>数组的count不能用 [array valueForKey:@”count”] ,会直接崩溃掉，可以使用[array valueForKey:@”@count”],这是数组的隐藏方法，类似的还有@max，@min，@sum；如果是keyPath的话，是[array valueFroKeyPath:@max.key]这样写。NSSet类型和数组类型相似，就不再举例了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">NSArray *arr0 = @[@1,@2,@2,@3,@1];</div><div class="line">NSLog(@&quot;@count:%@&quot;,[arr0 valueForKeyPath:@&quot;@count&quot;]);</div><div class="line">/// @count:5</div><div class="line">NSLog(@&quot;@avg:%@&quot;,[arr0 valueForKeyPath:@&quot;@avg.self&quot;]);</div><div class="line">/// @avg:1.8</div><div class="line">NSLog(@&quot;@unionOfObjects:%@&quot;,[arr0 valueForKeyPath:@&quot;@unionOfObjects.self&quot;]);</div><div class="line">/// @unionOfObjects:(</div><div class="line">    1,</div><div class="line">    2,</div><div class="line">    2,</div><div class="line">    3,</div><div class="line">    1</div><div class="line">)</div><div class="line">NSLog(@&quot;@distinctUnionOfObjects:%@&quot;,[arr0 valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;]);  //去重</div><div class="line">/// @distinctUnionOfObjects:(</div><div class="line">    3,</div><div class="line">    2,</div><div class="line">    1</div><div class="line">)</div><div class="line">NSArray *arr1 = @[@&quot;a&quot;,@&quot;b&quot;,@&quot;c&quot;,@&quot;a&quot;];</div><div class="line">NSArray *arr2 = @[arr0,arr1];</div><div class="line">NSLog(@&quot;@unionOfArrays:%@&quot;,[arr2 valueForKeyPath:@&quot;@unionOfArrays.self&quot;]);  //把多个数组合并成一个数组</div><div class="line">/// @unionOfArrays:(</div><div class="line">    1,</div><div class="line">    2,</div><div class="line">    2,</div><div class="line">    3,</div><div class="line">    1,</div><div class="line">    a,</div><div class="line">    b,</div><div class="line">    c,</div><div class="line">    a</div><div class="line">)</div><div class="line">NSLog(@&quot;@unionOfArrays:%@&quot;,[arr2 valueForKeyPath:@&quot;@distinctUnionOfArrays.self&quot;]);  //把多个数组合并成一个数组,并去重</div><div class="line">/// @unionOfArrays:(</div><div class="line">    c,</div><div class="line">    1,</div><div class="line">    2,</div><div class="line">    3,</div><div class="line">    a,</div><div class="line">    b</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>数组的valueForKey是对里边的每一个元素进行valueForKey，然后返回一个数组，如果数组中元素没有找到，就会返回一个含有N个null的数组</p>
<p>可以在分类中重写valueForKey方法，使数组也支持[array valueforkey:@”0”]这种取值方法，和字典的取值配合使用，也是挺方便的</p>
<p>关于kvc的东西还是挺多的，想了解更多可以看文档，文档写的还是挺清楚的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">	NSKeyValueCoding.h</div><div class="line">	Copyright (c) 1994-2016, Apple Inc. All rights reserved.</div><div class="line">*/</div><div class="line"></div><div class="line">#import &lt;Foundation/NSArray.h&gt;</div><div class="line">#import &lt;Foundation/NSDictionary.h&gt;</div><div class="line">#import &lt;Foundation/NSOrderedSet.h&gt;</div><div class="line">#import &lt;Foundation/NSSet.h&gt;</div><div class="line">#import &lt;Foundation/NSException.h&gt;</div><div class="line"></div><div class="line">@class NSError, NSString;</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_BEGIN</div><div class="line"></div><div class="line">/* The exception that is thrown when a key value coding operation fails. The exception&apos;s user info dictionary will contain at least two entries:</div><div class="line">    - @&quot;NSTargetObjectUserInfoKey&quot;: the receiver of the failed KVC message.</div><div class="line">    - @&quot;NSUnknownUserInfoKey&quot;: the key that was used in the failed KVC message.</div><div class="line"></div><div class="line">The actual value of this constant string is &quot;NSUnknownKeyException,&quot; to match the exceptions that are thrown by KVC methods that were deprecated in Mac OS 10.3.</div><div class="line">*/</div><div class="line">FOUNDATION_EXPORT NSExceptionName const NSUndefinedKeyException;</div><div class="line"></div><div class="line">typedef NSString * NSKeyValueOperator NS_STRING_ENUM;</div><div class="line"></div><div class="line">/* Strings for the names of array operators supported by key-value coding. Only these string declarations are new in Mac OS 10.4. The actual support for array operators appeared in Mac OS 10.3. The values of these do not include &quot;@&quot; prefixes.</div><div class="line">*/</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSAverageKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSCountKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSDistinctUnionOfArraysKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSDistinctUnionOfObjectsKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSDistinctUnionOfSetsKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSMaximumKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSMinimumKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSSumKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSUnionOfArraysKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSUnionOfObjectsKeyValueOperator;</div><div class="line">FOUNDATION_EXPORT NSKeyValueOperator const NSUnionOfSetsKeyValueOperator;</div><div class="line"></div><div class="line">@interface NSObject(NSKeyValueCoding)</div><div class="line"></div><div class="line">/* Return YES if -valueForKey:, -setValue:forKey:, -mutableArrayValueForKey:, -storedValueForKey:, -takeStoredValue:forKey:, and -takeValue:forKey: may directly manipulate instance variables when sent to instances of the receiving class, NO otherwise. The default implementation of this property returns YES.</div><div class="line">*/</div><div class="line">#if FOUNDATION_SWIFT_SDK_EPOCH_AT_LEAST(8)</div><div class="line">@property (class, readonly) BOOL accessInstanceVariablesDirectly;</div><div class="line">#endif</div><div class="line"></div><div class="line">/* Given a key that identifies an attribute or to-one relationship, return the attribute value or the related object. Given a key that identifies a to-many relationship, return an immutable array or an immutable set that contains all of the related objects.</div><div class="line">    </div><div class="line">The default implementation of this method does the following:</div><div class="line">    1. Searches the class of the receiver for an accessor method whose name matches the pattern -get&lt;Key&gt;, -&lt;key&gt;, or -is&lt;Key&gt;, in that order. If such a method is found it is invoked. If the type of the method&apos;s result is an object pointer type the result is simply returned. If the type of the result is one of the scalar types supported by NSNumber conversion is done and an NSNumber is returned. Otherwise, conversion is done and an NSValue is returned (new in Mac OS 10.5: results of arbitrary type are converted to NSValues, not just NSPoint, NRange, NSRect, and NSSize).</div><div class="line">    2 (introduced in Mac OS 10.7). Otherwise (no simple accessor method is found), searches the class of the receiver for methods whose names match the patterns -countOf&lt;Key&gt; and -indexIn&lt;Key&gt;OfObject: and -objectIn&lt;Key&gt;AtIndex: (corresponding to the primitive methods defined by the NSOrderedSet class) and also -&lt;key&gt;AtIndexes: (corresponding to -[NSOrderedSet objectsAtIndexes:]). If a count method and an indexOf method and at least one of the other two possible methods are found, a collection proxy object that responds to all NSOrderedSet methods is returned. Each NSOrderedSet message sent to the collection proxy object will result in some combination of -countOf&lt;Key&gt;, -indexIn&lt;Key&gt;OfObject:, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes: messages being sent to the original receiver of -valueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -get&lt;Key&gt;:range: that method will be used when appropriate for best performance.</div><div class="line">    3. Otherwise (no simple accessor method or set of ordered set access methods is found), searches the class of the receiver for methods whose names match the patterns -countOf&lt;Key&gt; and -objectIn&lt;Key&gt;AtIndex: (corresponding to the primitive methods defined by the NSArray class) and (introduced in Mac OS 10.4) also -&lt;key&gt;AtIndexes: (corresponding to -[NSArray objectsAtIndexes:]). If a count method and at least one of the other two possible methods are found, a collection proxy object that responds to all NSArray methods is returned. Each NSArray message sent to the collection proxy object will result in some combination of -countOf&lt;Key&gt;, -objectIn&lt;Key&gt;AtIndex:, and -&lt;key&gt;AtIndexes: messages being sent to the original receiver of -valueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -get&lt;Key&gt;:range: that method will be used when appropriate for best performance.</div><div class="line">    4 (introduced in Mac OS 10.4). Otherwise (no simple accessor method or set of ordered set or array access methods is found), searches the class of the receiver for a threesome of methods whose names match the patterns -countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;: (corresponding to the primitive methods defined by the NSSet class). If all three such methods are found a collection proxy object that responds to all NSSet methods is returned. Each NSSet message sent to the collection proxy object will result in some combination of -countOf&lt;Key&gt;, -enumeratorOf&lt;Key&gt;, and -memberOf&lt;Key&gt;: messages being sent to the original receiver of -valueForKey:.</div><div class="line">    5. Otherwise (no simple accessor method or set of collection access methods is found), if the receiver&apos;s class&apos; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found, the value of the instance variable in the receiver is returned, with the same sort of conversion to NSNumber or NSValue as in step 1.</div><div class="line">    6. Otherwise (no simple accessor method, set of collection access methods, or instance variable is found), invokes -valueForUndefinedKey: and returns the result. The default implementation of -valueForUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</div><div class="line"></div><div class="line">Compatibility notes:</div><div class="line">    - For backward binary compatibility, an accessor method whose name matches the pattern -_get&lt;Key&gt;, or -_&lt;key&gt; is searched for between steps 1 and 3. If such a method is found it is invoked, with the same sort of conversion to NSNumber or NSValue as in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</div><div class="line">    - The behavior described in step 5 is a change from Mac OS 10.2, in which the instance variable search order was &lt;key&gt;, _&lt;key&gt;.</div><div class="line">    - For backward binary compatibility, -handleQueryWithUnboundKey: will be invoked instead of -valueForUndefinedKey: in step 6, if the implementation of -handleQueryWithUnboundKey: in the receiver&apos;s class is not NSObject&apos;s.</div><div class="line">*/</div><div class="line">- (nullable id)valueForKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Given a value and a key that identifies an attribute, set the value of the attribute. Given an object and a key that identifies a to-one relationship, relate the object to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.</div><div class="line"></div><div class="line">The default implementation of this method does the following:</div><div class="line">    1. Searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found the type of its parameter is checked. If the parameter type is not an object pointer type but the value is nil -setNilValueForKey: is invoked. The default implementation of -setNilValueForKey: raises an NSInvalidArgumentException, but you can override it in your application. Otherwise, if the type of the method&apos;s parameter is an object pointer type the method is simply invoked with the value as the argument. If the type of the method&apos;s parameter is some other type the inverse of the NSNumber/NSValue conversion done by -valueForKey: is performed before the method is invoked.</div><div class="line">    2. Otherwise (no accessor method is found), if the receiver&apos;s class&apos; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, or is&lt;Key&gt;, in that order. If such an instance variable is found and its type is an object pointer type the value is retained and the result is set in the instance variable, after the instance variable&apos;s old value is first released. If the instance variable&apos;s type is some other type its value is set after the same sort of conversion from NSNumber or NSValue as in step 1.</div><div class="line">    3. Otherwise (no accessor method or instance variable is found), invokes -setValue:forUndefinedKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</div><div class="line"></div><div class="line">Compatibility notes:</div><div class="line">    - For backward binary compatibility with -takeValue:forKey:&apos;s behavior, a method whose name matches the pattern -_set&lt;Key&gt;: is also recognized in step 1. KVC accessor methods whose names start with underscores were deprecated as of Mac OS 10.3 though.</div><div class="line">    - For backward binary compatibility, -unableToSetNilForKey: will be invoked instead of -setNilValueForKey: in step 1, if the implementation of -unableToSetNilForKey: in the receiver&apos;s class is not NSObject&apos;s.</div><div class="line">    - The behavior described in step 2 is different from -takeValue:forKey:&apos;s, in which the instance variable search order is &lt;key&gt;, _&lt;key&gt;.</div><div class="line">    - For backward binary compatibility with -takeValue:forKey:&apos;s behavior, -handleTakeValue:forUnboundKey: will be invoked instead of -setValue:forUndefinedKey: in step 3, if the implementation of -handleTakeValue:forUnboundKey: in the receiver&apos;s class is not NSObject&apos;s.</div><div class="line">*/</div><div class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Given a pointer to a value pointer, a key that identifies an attribute or to-one relationship, and a pointer to an NSError pointer, return a value that is suitable for use in subsequent -setValue:forKey: messages sent to the same receiver. If no validation is necessary, return YES without altering *ioValue or *outError. If validation is necessary and possible, return YES after setting *ioValue to an object that is the validated version of the original value, but without altering *outError. If validation is necessary but not possible, return NO after setting *outError to an NSError that encapsulates the reason that validation was not possible, but without altering *ioValue. The sender of the message is never given responsibility for releasing ioValue or outError.</div><div class="line"></div><div class="line">The default implementation of this method searches the class of the receiver for a validator method whose name matches the pattern -validate&lt;Key&gt;:error:. If such a method is found it is invoked and the result is returned. If no such method is found, YES is returned.</div><div class="line">*/</div><div class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;</div><div class="line"></div><div class="line">/* Given a key that identifies an _ordered_ to-many relationship, return a mutable array that provides read-write access to the related objects. Objects added to the mutable array will become related to the receiver, and objects removed from the mutable array will become unrelated.</div><div class="line"></div><div class="line">The default implementation of this method recognizes the same simple accessor methods and array accessor methods as -valueForKey:&apos;s, and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that -valueForKey: would return. It also:</div><div class="line">    1. Searches the class of the receiver for methods whose names match the patterns -insertObject:in&lt;Key&gt;AtIndex: and -removeObjectFrom&lt;Key&gt;AtIndex: (corresponding to the two most primitive methods defined by the NSMutableArray class), and (introduced in Mac OS 10.4) also -insert&lt;Key&gt;:atIndexes: and -remove&lt;Key&gt;AtIndexes: (corresponding to -[NSMutableArray insertObjects:atIndexes:] and -[NSMutableArray removeObjectsAtIndexes:). If at least one insertion method and at least one removal method are found each NSMutableArray message sent to the collection proxy object will result in some combination of -insertObject:in&lt;Key&gt;AtIndex:, -removeObjectFrom&lt;Key&gt;AtIndex:, -insert&lt;Key&gt;:atIndexes:, and -remove&lt;Key&gt;AtIndexes: messages being sent to the original receiver of -mutableArrayValueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -replaceObjectIn&lt;Key&gt;AtIndex:withObject: or (introduced in Mac OS 10.4) -replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;: that method will be used when appropriate for best performance.</div><div class="line">    2. Otherwise (no set of array mutation methods is found), searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found each NSMutableArray message sent to the collection proxy object will result in a -set&lt;Key&gt;: message being sent to the original receiver of -mutableArrayValueForKey:.</div><div class="line">    3. Otherwise (no set of array mutation methods or simple accessor method is found), if the receiver&apos;s class&apos; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt; or &lt;key&gt;, in that order. If such an instance variable is found, each NSMutableArray message sent to the collection proxy object will be forwarded to the instance variable&apos;s value, which therefore must typically be an instance of NSMutableArray or a subclass of NSMutableArray.</div><div class="line">    4. Otherwise (no set of array mutation methods, simple accessor method, or instance variable is found), returns a mutable collection proxy object anyway. Each NSMutableArray message sent to the collection proxy object will result in a -setValue:forUndefinedKey: message being sent to the original receiver of -mutableArrayValueForKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</div><div class="line"></div><div class="line">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step 2&apos;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</div><div class="line">*/</div><div class="line">- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Given a key that identifies an _ordered_ and uniquing to-many relationship, return a mutable ordered set that provides read-write access to the related objects. Objects added to the mutable ordered set will become related to the receiver, and objects removed from the mutable ordered set will become unrelated.</div><div class="line"></div><div class="line">The default implementation of this method recognizes the same simple accessor methods and ordered set accessor methods as -valueForKey:&apos;s, and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that -valueForKey: would return. It also:</div><div class="line">    1. Searches the class of the receiver for methods whose names match the patterns -insertObject:in&lt;Key&gt;AtIndex: and -removeObjectFrom&lt;Key&gt;AtIndex: (corresponding to the two most primitive methods defined by the NSMutableOrderedSet class), and also -insert&lt;Key&gt;:atIndexes: and -remove&lt;Key&gt;AtIndexes: (corresponding to -[NSMutableOrderedSet insertObjects:atIndexes:] and -[NSMutableOrderedSet removeObjectsAtIndexes:). If at least one insertion method and at least one removal method are found each NSMutableOrderedSet message sent to the collection proxy object will result in some combination of -insertObject:in&lt;Key&gt;AtIndex:, -removeObjectFrom&lt;Key&gt;AtIndex:, -insert&lt;Key&gt;:atIndexes:, and -remove&lt;Key&gt;AtIndexes: messages being sent to the original receiver of -mutableOrderedSetValueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -replaceObjectIn&lt;Key&gt;AtIndex:withObject: or -replace&lt;Key&gt;AtIndexes:with&lt;Key&gt;: that method will be used when appropriate for best performance.</div><div class="line">    2. Otherwise (no set of ordered set mutation methods is found), searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found each NSMutableOrderedSet message sent to the collection proxy object will result in a -set&lt;Key&gt;: message being sent to the original receiver of -mutableOrderedSetValueForKey:.</div><div class="line">    3. Otherwise (no set of ordered set mutation methods or simple accessor method is found), if the receiver&apos;s class&apos; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt; or &lt;key&gt;, in that order. If such an instance variable is found, each NSMutableOrderedSet message sent to the collection proxy object will be forwarded to the instance variable&apos;s value, which therefore must typically be an instance of NSMutableOrderedSet or a subclass of NSMutableOrderedSet.</div><div class="line">    4. Otherwise (no set of ordered set mutation methods, simple accessor method, or instance variable is found), returns a mutable collection proxy object anyway. Each NSMutableOrderedSet message sent to the collection proxy object will result in a -setValue:forUndefinedKey: message being sent to the original receiver of -mutableOrderedSetValueForKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</div><div class="line"></div><div class="line">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step 2&apos;s description are a potential performance problem. For better performance implement insertion and removal methods that fulfill the requirements for step 1 in your KVC-compliant class. For best performance implement a replacement method too.</div><div class="line">*/</div><div class="line">- (NSMutableOrderedSet *)mutableOrderedSetValueForKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);</div><div class="line"></div><div class="line">/* Given a key that identifies an _unordered_ and uniquing to-many relationship, return a mutable set that provides read-write access to the related objects. Objects added to the mutable set will become related to the receiver, and objects removed from the mutable set will become unrelated.</div><div class="line"></div><div class="line">The default implementation of this method recognizes the same simple accessor methods and set accessor methods as -valueForKey:&apos;s, and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that -valueForKey: would return. It also:</div><div class="line">    1. Searches the class of the receiver for methods whose names match the patterns -add&lt;Key&gt;Object: and -remove&lt;Key&gt;Object: (corresponding to the two primitive methods defined by the NSMutableSet class) and also -add&lt;Key&gt;: and -remove&lt;Key&gt;: (corresponding to -[NSMutableSet unionSet:] and -[NSMutableSet minusSet:]). If at least one addition method and at least one removal method are found each NSMutableSet message sent to the collection proxy object will result in some combination of -add&lt;Key&gt;Object:, -remove&lt;Key&gt;Object:, -add&lt;Key&gt;:, and -remove&lt;Key&gt;: messages being sent to the original receiver of -mutableSetValueForKey:. If the class of the receiver also implements an optional method whose name matches the pattern -intersect&lt;Key&gt;: or -set&lt;Key&gt;: that method will be used when appropriate for best performance.</div><div class="line">    2. Otherwise (no set of set mutation methods is found), searches the class of the receiver for an accessor method whose name matches the pattern -set&lt;Key&gt;:. If such a method is found each NSMutableSet message sent to the collection proxy object will result in a -set&lt;Key&gt;: message being sent to the original receiver of -mutableSetValueForKey:.</div><div class="line">    3. Otherwise (no set of set mutation methods or simple accessor method is found), if the receiver&apos;s class&apos; +accessInstanceVariablesDirectly property returns YES, searches the class of the receiver for an instance variable whose name matches the pattern _&lt;key&gt; or &lt;key&gt;, in that order. If such an instance variable is found, each NSMutableSet message sent to the collection proxy object will be forwarded to the instance variable&apos;s value, which therefore must typically be an instance of NSMutableSet or a subclass of NSMutableSet.</div><div class="line">    4. Otherwise (no set of set mutation methods, simple accessor method, or instance variable is found), returns a mutable collection proxy object anyway. Each NSMutableSet message sent to the collection proxy object will result in a -setValue:forUndefinedKey: message being sent to the original receiver of -mutableSetValueForKey:. The default implementation of -setValue:forUndefinedKey: raises an NSUndefinedKeyException, but you can override it in your application.</div><div class="line"></div><div class="line">Performance note: the repetitive -set&lt;Key&gt;: messages implied by step 2&apos;s description are a potential performance problem. For better performance implement methods that fulfill the requirements for step 1 in your KVC-compliant class.</div><div class="line">*/</div><div class="line">- (NSMutableSet *)mutableSetValueForKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Key-path-taking variants of like-named methods. The default implementation of each parses the key path enough to determine whether or not it has more than one component (key path components are separated by periods). If so, -valueForKey: is invoked with the first key path component as the argument, and the method being invoked is invoked recursively on the result, with the remainder of the key path passed as an argument. If not, the like-named non-key-path-taking method is invoked.</div><div class="line">*/</div><div class="line">- (nullable id)valueForKeyPath:(NSString *)keyPath;</div><div class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</div><div class="line">- (BOOL)validateValue:(inout id _Nullable * _Nonnull)ioValue forKeyPath:(NSString *)inKeyPath error:(out NSError **)outError;</div><div class="line">- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;</div><div class="line">- (NSMutableOrderedSet *)mutableOrderedSetValueForKeyPath:(NSString *)keyPath NS_AVAILABLE(10_7, 5_0);</div><div class="line">- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath;</div><div class="line"></div><div class="line">/* Given that an invocation of -valueForKey: would be unable to get a keyed value using its default access mechanism, return the keyed value using some other mechanism. The default implementation of this method raises an NSUndefinedKeyException. You can override it to handle properties that are dynamically defined at run-time.</div><div class="line">*/</div><div class="line">- (nullable id)valueForUndefinedKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Given that an invocation of -setValue:forKey: would be unable to set the keyed value using its default mechanism, set the keyed value using some other mechanism. The default implementation of this method raises an NSUndefinedKeyException. You can override it to handle properties that are dynamically defined at run-time.</div><div class="line">*/</div><div class="line">- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Given that an invocation of -setValue:forKey: would be unable to set the keyed value because the type of the parameter of the corresponding accessor method is an NSNumber scalar type or NSValue structure type but the value is nil, set the keyed value using some other mechanism. The default implementation of this method raises an NSInvalidArgumentException. You can override it to map nil values to something meaningful in the context of your application.</div><div class="line">*/</div><div class="line">- (void)setNilValueForKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Given an array of keys, return a dictionary containing the keyed attribute values, to-one-related objects, and/or collections of to-many-related objects. Entries for which -valueForKey: returns nil have NSNull as their value in the returned dictionary.</div><div class="line">*/</div><div class="line">- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;</div><div class="line"></div><div class="line">/* Given a dictionary containing keyed attribute values, to-one-related objects, and/or collections of to-many-related objects, set the keyed values. Dictionary entries whose values are NSNull result in -setValue:nil forKey:key messages being sent to the receiver.</div><div class="line">*/</div><div class="line">- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSArray&lt;ObjectType&gt;(NSKeyValueCoding)</div><div class="line"></div><div class="line">/* Return an array containing the results of invoking -valueForKey: on each of the receiver&apos;s elements. The returned array will contain NSNull elements for each instance of -valueForKey: returning nil.</div><div class="line">*/</div><div class="line">- (id)valueForKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Invoke -setValue:forKey: on each of the receiver&apos;s elements.</div><div class="line">*/</div><div class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSDictionary&lt;KeyType, ObjectType&gt;(NSKeyValueCoding)</div><div class="line"></div><div class="line">/* Return the result of sending -objectForKey: to the receiver.</div><div class="line">*/</div><div class="line">- (nullable ObjectType)valueForKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSMutableDictionary&lt;KeyType, ObjectType&gt;(NSKeyValueCoding)</div><div class="line"></div><div class="line">/* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObjectForKey:.</div><div class="line">*/</div><div class="line">- (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSOrderedSet&lt;ObjectType&gt;(NSKeyValueCoding)</div><div class="line"></div><div class="line">/* Return an ordered set containing the results of invoking -valueForKey: on each of the receiver&apos;s members. The returned ordered set might not have the same number of members as the receiver. The returned ordered set will not contain any elements corresponding to instances of -valueForKey: returning nil, nor will it contain duplicates.</div><div class="line">*/</div><div class="line">- (id)valueForKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);</div><div class="line"></div><div class="line">/* Invoke -setValue:forKey: on each of the receiver&apos;s members.</div><div class="line">*/</div><div class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key NS_AVAILABLE(10_7, 5_0);</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface NSSet&lt;ObjectType&gt;(NSKeyValueCoding)</div><div class="line"></div><div class="line">/* Return a set containing the results of invoking -valueForKey: on each of the receiver&apos;s members. The returned set might not have the same number of members as the receiver. The returned set will not contain any elements corresponding to instances of -valueForKey: returning nil (in contrast with -[NSArray(NSKeyValueCoding) valueForKey:], which may put NSNulls in the arrays it returns).</div><div class="line">*/</div><div class="line">- (id)valueForKey:(NSString *)key;</div><div class="line"></div><div class="line">/* Invoke -setValue:forKey: on each of the receiver&apos;s members.</div><div class="line">*/</div><div class="line">- (void)setValue:(nullable id)value forKey:(NSString *)key;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE))</div><div class="line"></div><div class="line">@interface NSObject(NSDeprecatedKeyValueCoding)</div><div class="line"></div><div class="line">/* Methods that were deprecated in Mac OS 10.4.</div><div class="line">*/</div><div class="line">+ (BOOL)useStoredAccessor NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);</div><div class="line">- (nullable id)storedValueForKey:(NSString *)key NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);</div><div class="line">- (void)takeStoredValue:(nullable id)value forKey:(NSString *)key NS_DEPRECATED(10_0, 10_4, 2_0, 2_0);</div><div class="line"></div><div class="line">/* Methods that were deprecated in Mac OS 10.3. Use the new, more consistently named, methods declared above instead.</div><div class="line">*/</div><div class="line">- (void)takeValue:(nullable id)value forKey:(NSString *)key NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line">- (void)takeValue:(nullable id)value forKeyPath:(NSString *)keyPath NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line">- (nullable id)handleQueryWithUnboundKey:(NSString *)key NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line">- (void)handleTakeValue:(nullable id)value forUnboundKey:(NSString *)key NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line">- (void)unableToSetNilForKey:(NSString *)key NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line">- (NSDictionary *)valuesForKeys:(NSArray *)keys NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line">- (void)takeValuesFromDictionary:(NSDictionary *)properties NS_DEPRECATED(10_0, 10_3, 2_0, 2_0);</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">#endif</div><div class="line"></div><div class="line">NS_ASSUME_NONNULL_END</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/26/ios-kvc-kvo/" data-id="cj4znzen60002icfyvt5l8icz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/07/01/KVO-原理与总结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          KVO 原理与总结
        
      </div>
    </a>
  
  
    <a href="/2017/02/28/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/07/01/KVO-原理与总结/">KVO 原理与总结</a>
          </li>
        
          <li>
            <a href="/2017/06/26/ios-kvc-kvo/">iOS KVC 原理与总结</a>
          </li>
        
          <li>
            <a href="/2017/02/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>